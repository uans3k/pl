package golang

var goLexerTemplate = `// Code generated by u3k_lexer. DO NOT EDIT.
package {{.Package}}

import (
	"github.com/pkg/errors"
	"io"
	runtime "{{.Runtime}}"
)

type tokenType struct{
	str string
}

func newTokenType(str string) runtime.TokenType{
	return &tokenType{
		str: str,
	}
}

func(t *tokenType) String() string{
	return t.str
}

type tokenValue struct{
	chars []rune
}

func newTokenValue(chars []rune) runtime.TokenValue{
	return &tokenValue{
		chars: chars,
	}
}

func (t *tokenValue) String() string{
	return string(t.chars)
}

func (t *tokenValue) Chars() []rune{
	return t.chars
}

var(
	{{ range $tokenType,$b := .TokenTypes }}
	TokenType_{{$tokenType}} runtime.TokenType = newTokenType("{{$tokenType}}")
	{{ end }}
	acceptState2TokenType = map[int]runtime.TokenType{
		{{ range $state,$tokenType := .AcceptState2TokenType }}
			{{$state}} : TokenType_{{$tokenType.Name}},
		{{ end }}
	}
	tokenType2FuncCalls = map[runtime.TokenType][]string{
		{{ range $tokenType,$funCalls := .TokenType2FuncCalls }}
			TokenType_{{$tokenType}} :{ {{range $i,$funcCall :=$funCalls}}{{if ne $i 0}},{{end}}"{{$funcCall}}"{{end}} },
		{{ end }}
	}
)

func accept(state int) (ok bool){
	_,ok = acceptState2TokenType[state]
	return
}

type lexer struct{
	stream runtime.CharStream
	row  int
	col  int
	latestToken []rune
}

func NewLexer(stream runtime.CharStream) runtime.Lexer{
	return &lexer{
		stream : stream,
	}
}

func (l *lexer) handleFuncCalls(funcCalls []string) (skip bool){
	for _,funcCall:=range funcCalls{
		switch funcCall{
		case "Hidden":
			skip = true
		case "Row":
			l.row++
			l.col=0
		}
	}
	return 
}

func (l *lexer) NextToken() (*runtime.Token,error){
sInit:
	var(
    	badState 	= -1
		states   	= []int{badState}
		curState 	= 0
		char rune 	= 0
		err  error 	= nil
	)
	goto s0
{{ range $state,$edges := .State2Edges }}
s{{$state}}:
	if accept({{$state}}){
		states = nil
	}
    states = append(states,{{$state}})
	char,err = l.stream.NextChar()
	if err!=nil{
		goto sEnd
	}
	{{if eq (len $edges) 0 }}goto sEnd{{ else }}
	{{ range $i,$edge := $edges }}{{ if eq $i 0 }}if{{ else }}else if{{ end }}{{ range $j,$char := $edge.Chars }}{{ if ne $j 0 }}||{{ end }} {{CharCompare $char}} {{ end }}{
		goto s{{$edge.ToState}}
	}{{ end }}else{
		goto sEnd
	}{{ end }}
{{ end }}

sEnd:
	if err!=nil && err != io.EOF{
		return nil,err
	}
	for curState!=badState && !accept(curState) {
		curState = states[len(states)-1]
		states = states[0:len(states)-1]
		l.stream.Rollback()
	}
	if acceptTokenType,ok:= acceptState2TokenType[curState];ok{
		tokenStr:=l.stream.Consume()
		if funcCalls,ok:=  tokenType2FuncCalls[acceptTokenType];ok{
			if l.handleFuncCalls(funcCalls){
				goto sInit
			}
		}
		col := l.col
		l.col++
		l.latestToken = tokenStr
		return &runtime.Token{
			Value : newTokenValue(tokenStr),
			Type  : acceptTokenType,
			Row	  : l.row,
			Column: col,
		},nil
	}else if err!=nil{
		return nil,err
	}else{
		return nil,errors.Wrapf(runtime.InvalidToken,"[row : %d ,col :%d ,latest token :%s]",l.row,l.col,string(l.latestToken))
	}
}
`
