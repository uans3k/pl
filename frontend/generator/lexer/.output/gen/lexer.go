// Code generated by u3k_lexer. DO NOT EDIT.
package gen

import (
	"github.com/pkg/errors"
	"io"
	runtime "github.com/uans3k/pl/frontend/runtime/lexer"
)

type tokenType struct{
	str string
}

func newTokenType(str string) runtime.TokenType{
	return &tokenType{
		str: str,
	}
}

func(t *tokenType) String() string{
	return t.str
}

type tokenValue struct{
	chars []rune
}

func newTokenValue(chars []rune) runtime.TokenValue{
	return &tokenValue{
		chars: chars,
	}
}

func (t *tokenValue) String() string{
	return string(t.chars)
}

func (t *tokenValue) Chars() []rune{
	return t.chars
}

var(
	
	TokenType_left_b runtime.TokenType = newTokenType("left_b")
	
	TokenType_line runtime.TokenType = newTokenType("line")
	
	TokenType_number runtime.TokenType = newTokenType("number")
	
	TokenType_right_b runtime.TokenType = newTokenType("right_b")
	
	TokenType_string runtime.TokenType = newTokenType("string")
	
	TokenType_white runtime.TokenType = newTokenType("white")
	
	acceptState2TokenType = map[int]runtime.TokenType{
		
			1 : TokenType_string,
		
			2 : TokenType_left_b,
		
			3 : TokenType_right_b,
		
			4 : TokenType_line,
		
			5 : TokenType_number,
		
			6 : TokenType_number,
		
			7 : TokenType_white,
		
	}
	tokenType2FuncCalls = map[runtime.TokenType][]string{
		
			TokenType_left_b :{  },
		
			TokenType_line :{ "Hidden","Row" },
		
			TokenType_number :{  },
		
			TokenType_right_b :{  },
		
			TokenType_string :{  },
		
			TokenType_white :{ "Hidden" },
		
	}
)

func accept(state int) (ok bool){
	_,ok = acceptState2TokenType[state]
	return
}

type lexer struct{
	stream runtime.CharStream
	row  int
	col  int
	latestToken []rune
}

func NewLexer(stream runtime.CharStream) runtime.Lexer{
	return &lexer{
		stream : stream,
	}
}

func (l *lexer) handleFuncCalls(funcCalls []string) (skip bool){
	for _,funcCall:=range funcCalls{
		switch funcCall{
		case "Hidden":
			skip = true
		case "Row":
			l.row++
			l.col=0
		}
	}
	return 
}

func (l *lexer) NextToken() (*runtime.Token,error){
sInit:
	var(
    	badState 	= -1
		states   	= []int{badState}
		curState 	= 0
		char rune 	= 0
		err  error 	= nil
	)
	goto s0

s0:
	if accept(0){
		states = nil
	}
    states = append(states,0)
	char,err = l.stream.NextChar()
	if err!=nil{
		goto sEnd
	}
	switch char {
    
	case   99  , 97  , 98 :
		goto s1
	
	case   123 :
		goto s2
	
	case   125 :
		goto s3
	
	case   10 :
		goto s4
	
	case   48 :
		goto s5
	
	case   49 :
		goto s6
	
	case   32  , 9 :
		goto s7
	
	default:
		goto sEnd
	}


s1:
	if accept(1){
		states = nil
	}
    states = append(states,1)
	char,err = l.stream.NextChar()
	if err!=nil{
		goto sEnd
	}
	switch char {
    
	case   48  , 49  , 99  , 98  , 97 :
		goto s1
	
	default:
		goto sEnd
	}


s2:
	if accept(2){
		states = nil
	}
    states = append(states,2)
	char,err = l.stream.NextChar()
	if err!=nil{
		goto sEnd
	}
	switch char {
    
	default:
		goto sEnd
	}


s3:
	if accept(3){
		states = nil
	}
    states = append(states,3)
	char,err = l.stream.NextChar()
	if err!=nil{
		goto sEnd
	}
	switch char {
    
	default:
		goto sEnd
	}


s4:
	if accept(4){
		states = nil
	}
    states = append(states,4)
	char,err = l.stream.NextChar()
	if err!=nil{
		goto sEnd
	}
	switch char {
    
	default:
		goto sEnd
	}


s5:
	if accept(5){
		states = nil
	}
    states = append(states,5)
	char,err = l.stream.NextChar()
	if err!=nil{
		goto sEnd
	}
	switch char {
    
	default:
		goto sEnd
	}


s6:
	if accept(6){
		states = nil
	}
    states = append(states,6)
	char,err = l.stream.NextChar()
	if err!=nil{
		goto sEnd
	}
	switch char {
    
	case   49  , 48 :
		goto s6
	
	default:
		goto sEnd
	}


s7:
	if accept(7){
		states = nil
	}
    states = append(states,7)
	char,err = l.stream.NextChar()
	if err!=nil{
		goto sEnd
	}
	switch char {
    
	default:
		goto sEnd
	}



sEnd:
	if err!=nil && err != io.EOF{
		return nil,err
	}
	for curState!=badState && !accept(curState) {
		curState = states[len(states)-1]
		states = states[0:len(states)-1]
		l.stream.Rollback()
	}
	if acceptTokenType,ok:= acceptState2TokenType[curState];ok{
		tokenStr:=l.stream.Consume()
		if funcCalls,ok:=  tokenType2FuncCalls[acceptTokenType];ok{
			if l.handleFuncCalls(funcCalls){
				goto sInit
			}
		}
		col := l.col
		l.col++
		l.latestToken = tokenStr
		return &runtime.Token{
			Value : newTokenValue(tokenStr),
			Type  : acceptTokenType,
			Row	  : l.row,
			Column: col,
		},nil
	}else if err!=nil{
		return nil,err
	}else{
		return nil,errors.Wrapf(runtime.InvalidToken,"[row : %d ,col :%d ,latest token :%s]",l.row,l.col,string(l.latestToken))
	}
}
